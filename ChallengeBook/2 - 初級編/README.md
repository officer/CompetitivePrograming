# Overview
DFS、BFSについては既に知っているため割愛。
Greedyから始める。

## 2-2 貪欲法
あるルールにしたがって、その場での最善な方法を選択することを繰り返す、というもの。

### 例題1,2
単純で自明だったため割愛

### 例題3 (Fence Repair)
```math
長さNの板から、 L_1,L_2...L_i の長さの板を切り出すことを考える。
元の板の長さはこれらの合計に等しい。
板を切る時、切る前の板の長さがコストとして消費される。もっともコストを低くする方法を探す。
```
ただ単純に小さく切っていくだけではダメで、いかに「元の長さ」を小さくしていくかが鍵になる。

#### 解法
切り出すという操作は、1つの大きい板が2つの小さい板に分割されるという操作になることから、2分木のような作りになる。

そして、問題の性質から、葉の長さ * 深さを合計したものがコストになると考えることが可能である。

ということは、一番短いものは、その次に一番短いものとくっつけられているはずである。何故なら、二分木である都合上、[一番底にある一番小さい葉にも、同じ深さの相棒が居る]はずであって、[一番底にある]のであれば、それは他のあらゆる葉よりも小さくなくてはならないので、必然的にそれは二番目に小さい葉になる。

これは再帰的に適用できるため、以下のような仕組みで解くことができる。

1. ソートする
2. 先頭から2つ取り出し、コストに追加する
3. [2]を再度列に入れ直す
4. [1]-[3]を繰り返し、要素が一つになった段階で終了する。

Priority Queueを使えば簡単に解けそうだが、二分木を使う方法があるらしい。


## 2-3 動的計画法
### ナップザック問題
それぞれに重さwと価値vが定義された品数がN個ある。

重さの総和がWを超えないようにした場合の価値の総和を求める。

ただし、品物は一度しか入れることが出来ない。
```math
1 \leq n \leq 100
1 \leq w,v \leq 100
1 \leq W \leq 10000
```

#### 解法
純粋に解くのであれば、各品物に対して入れる or 入れないを考えることが出来て、重さに対して枝狩りをするような形にできる。

この場合オーダーは2のN乗となってしまい、指数的になってしまうので厳しい。

一度しか出来ないのであれば、dp[N][M]のようにして、N番目までの荷物の中から選ぶ際に、重さMになる場合の最大の価値をメモにすることで計算量NMで解くことが可能。


### 最長共通部分列問題
長さがそれぞれn,mであるような2つの文字列s,tがある。これら二つの最長部分文字列の長さを求める。

最長部分文字列については以下を参照

    https://ja.wikipedia.org/wiki/%E6%9C%80%E9%95%B7%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86%E5%88%97%E5%95%8F%E9%A1%8C

例えば、abcdとbecdの最長部分文字列はbcdであり、長さは3。

#### 解法
単純に部分文字列を全部比較することは当然ながら出来ない。

ここでは順番に考える。

例えば、sのi_n文字目まで、ないしtのj_n文字目までを使う部分文字列を考える。
この最長共通部分文字列の長さが3であったとする。

この状態で、sのi_n+1文字、tのj_n+1文字目までを使う場合を考える。この二つの文字列が同一であった場合、単純にプラスすれば良い。

dp[n][m]として、n,m文字目まで利用する場合の最長共通文字列の長さをメモしていけば計算時間はnmとなる。

### ナップザック問題その2
その1と同様だが、今回は個数制限がない。

#### 解法
極めて単純であるがNMで解ける。
重さがMであるような場合の最大の価値をdp[M]でメモし、各重さについて品番nを入れるdpをするだけで終わり。

個数制限がある場合より実は単純


### 個数制限付き部分和問題
n種類の数a_iがそれぞれm_i個ずつある。この中からいくつか選んで総和を丁度Kとすることか出来るか否かを考える。

#### 解法
a_iのi番目までの数字を利用して、数字jを作ることが出来るか？ということを考える。

これを考えるには、i-1番目の時はどうなのか？ということを考える必要がある。

どうしてかというと、i-1番目の時に任意の数字を作れていたかどうかが分かれば、あとは、その時のjの値にi番目の数字を何個足すかどうかだけを考える問題に帰着することが出来るからである。

例えば以下のような場合を考える。

    n = 3
    a_i = 1, 2, 3
    m_i = 3, 2, 4
    K = 10

a_iから順番に考えると、1番目の数字は1で、3個ある。

ということは、何も足さない場合も考えると0-3までの数字は作れる。

次に2番目の数値を考えると、先ほど作った0-3の数値に、2か、2*2を足した数値、あるいは何も足さない数値が全て作れる。

そうなるとつまり、2番目までの数字を使う場合には、0-7までの数値が全て作れる。

次は3番目の数値にーーーという具合に進めることが出来る。

しかしこの解法だと計算量が多く、iとkを走査しつつ、それぞれに対して0-m_i個使う場合をを考えなければならない。

つまりこの計算オーダーは以下の通りとなり、厳しい。

```math
\sum_{k=1}^{n} = m_i * K
```

#### もうちょっと良い解法
通常出来るか、出来ないかなどの情報量を削いだbool値のDPが無駄があることが多い。

というより、もっと最適な計算をするために使える情報をわざわざ削ぎ落としてしまっていて最適化の余地が残っている場合がある。

この場合だと、ループとしてはIの中にKがあるので、i番目の数値を固定して総和Kを動かしていく走査をすることになる。

この時、Kが低いうちにa_iを複数回足したあと、Kが大きくなった時に、a_iが何回か足されたものに再び0-m_i回足すシミュレーションをすることになり、重複が発生していることがわかる。

従って、dp[i+1][j]をjを作成した時に、i番目の数値があと何回使えるのか？(余るのか)ということを格納してあげれば、これが0以上か、-1(作れないか)かということで分けることが出来る。

この場合操作としては以下のようになる。

dp[i+1][j] の値は
    m_i (dp[i][j] => 0の場合)
        これを満たさない場合
    -1 (j < a_i　または dp[i+1][j-a_i] < 0の時)
        これを満たさない場合
    dp[i+1][j-a_i] - 1 (それ以外の時)

i+1にしているのは添え字が0から始まる問題なだけで、変えても良い。

これであればiとkを操作するだけで終わるので、オーダーはnKとなりだいぶマシになる。


